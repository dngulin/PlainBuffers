// This file is auto-generated by the PlainBuffers compiler
// Generated at 2020-09-30T23:10:44.7646769+03:00

// ReSharper disable All

using System;
using System.Runtime.InteropServices;

namespace PlainBuffers.Tests.GeneratedSafe {
    public enum ColorId : byte {
        Red = 0,
        Green = 1,
        Blue = 2
    }

    public readonly unsafe ref struct Vec {
        public const int SizeOf = 12;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public Vec(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public ref float X => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(0, sizeof(float)))[0];
        public ref float Y => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(4, sizeof(float)))[0];
        public ref float Z => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(8, sizeof(float)))[0];

        public void CopyTo(Vec other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            X = 0;
            Y = 0;
            Z = 0;
        }

        public static bool operator ==(Vec l, Vec r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(Vec l, Vec r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly unsafe ref struct Quat {
        public const int SizeOf = 16;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public Quat(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public ref float X => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(0, sizeof(float)))[0];
        public ref float Y => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(4, sizeof(float)))[0];
        public ref float Z => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(8, sizeof(float)))[0];
        public ref float W => ref MemoryMarshal.Cast<byte, float>(_buffer.Slice(12, sizeof(float)))[0];

        public void CopyTo(Quat other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            X = 0;
            Y = 0;
            Z = 0;
            W = 1;
        }

        public static bool operator ==(Quat l, Quat r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(Quat l, Quat r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly unsafe ref struct HandleArray5 {
        public const int SizeOf = 10;
        public const int Length = 5;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public HandleArray5(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public void CopyTo(HandleArray5 other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            for (var i = 0; i < Length; i++) {
                this[i] = -1;
            }
        }

        public ref short this[int index] => ref MemoryMarshal.Cast<byte, short>(_buffer.Slice(index * sizeof(short), sizeof(short)))[0];

        public _EnumeratorOfHandleArray5 GetEnumerator() => new _EnumeratorOfHandleArray5(this);

        public ref struct _EnumeratorOfHandleArray5 {
            private readonly HandleArray5 _array;
            private int _index;

            public _EnumeratorOfHandleArray5(HandleArray5 array) {
                _array = array;
                _index = -1;
            }

            public bool MoveNext() => ++_index < Length;
            public ref short Current => ref _array[_index];

            public void Reset() => _index = -1;
            public void Dispose() {}
        }

        public static bool operator ==(HandleArray5 l, HandleArray5 r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(HandleArray5 l, HandleArray5 r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly unsafe ref struct Monster {
        public const int SizeOf = 44;
        private const int _Padding = 2;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public Monster(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public Vec Position => new Vec(_buffer.Slice(0, Vec.SizeOf));
        public Quat Rotation => new Quat(_buffer.Slice(12, Quat.SizeOf));
        public ref short Hp => ref MemoryMarshal.Cast<byte, short>(_buffer.Slice(28, sizeof(short)))[0];
        public HandleArray5 Inventory => new HandleArray5(_buffer.Slice(30, HandleArray5.SizeOf));
        public ref bool Aggressive => ref MemoryMarshal.Cast<byte, bool>(_buffer.Slice(40, sizeof(bool)))[0];
        public ref ColorId Color => ref MemoryMarshal.Cast<byte, ColorId>(_buffer.Slice(41, sizeof(ColorId)))[0];

        public void CopyTo(Monster other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            Position.WriteDefault();
            Rotation.WriteDefault();
            Hp = 100;
            Inventory.WriteDefault();
            Aggressive = true;
            Color = ColorId.Blue;
            GetBuffer().Slice(SizeOf - _Padding, _Padding).Fill(0);
        }

        public static bool operator ==(Monster l, Monster r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(Monster l, Monster r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }
}
