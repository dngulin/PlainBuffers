// This file is auto-generated by the PlainBuffers compiler
// Generated at 2020-09-22T23:49:57.4494439+03:00

// ReSharper disable All

using System;
using PlainBuffers.Core;

namespace PlainBuffers.Tests.Generated {
    public enum ColorId : byte {
        Red = 0,
        Green = 1,
        Blue = 2
    }

    public readonly ref struct _PlainColorId {
        public const int SizeOf = 1;
        private readonly PlainUInt8 _primitive;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public _PlainColorId(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
            _primitive = new PlainUInt8(_buffer);
        }

        public ColorId Read() => (ColorId) _primitive.Read();
        public void Write(ColorId value) => _primitive.Write((byte) value);

        public void CopyTo(_PlainColorId other) => _buffer.CopyTo(other._buffer);

        public static bool operator ==(_PlainColorId l, _PlainColorId r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(_PlainColorId l, _PlainColorId r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly ref struct Vec {
        public const int SizeOf = 12;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public Vec(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public PlainFloat X => new PlainFloat(_buffer.Slice(0, PlainFloat.SizeOf));
        public PlainFloat Y => new PlainFloat(_buffer.Slice(4, PlainFloat.SizeOf));
        public PlainFloat Z => new PlainFloat(_buffer.Slice(8, PlainFloat.SizeOf));

        public void CopyTo(Vec other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            X.Write(0);
            Y.Write(0);
            Z.Write(0);
        }

        public static bool operator ==(Vec l, Vec r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(Vec l, Vec r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly ref struct Quat {
        public const int SizeOf = 16;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public Quat(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public PlainFloat X => new PlainFloat(_buffer.Slice(0, PlainFloat.SizeOf));
        public PlainFloat Y => new PlainFloat(_buffer.Slice(4, PlainFloat.SizeOf));
        public PlainFloat Z => new PlainFloat(_buffer.Slice(8, PlainFloat.SizeOf));
        public PlainFloat W => new PlainFloat(_buffer.Slice(12, PlainFloat.SizeOf));

        public void CopyTo(Quat other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            X.Write(0);
            Y.Write(0);
            Z.Write(0);
            W.Write(1);
        }

        public static bool operator ==(Quat l, Quat r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(Quat l, Quat r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly ref struct HandleArray5 {
        public const int SizeOf = 10;
        public const int Length = 5;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public HandleArray5(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public PlainInt16 this[int index] => new PlainInt16(_buffer.Slice(PlainInt16.SizeOf * index, PlainInt16.SizeOf));

        public void CopyTo(HandleArray5 other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            for (var i = 0; i < Length; i++) {
                this[i].Write(-1);
            }
        }

        public _EnumeratorOfHandleArray5 GetEnumerator() => new _EnumeratorOfHandleArray5(this);

        public ref struct _EnumeratorOfHandleArray5 {
            private readonly HandleArray5 _array;
            private int _index;

            public _EnumeratorOfHandleArray5(HandleArray5 array) {
                _array = array;
                _index = -1;
            }

            public bool MoveNext() => ++_index < Length;
            public PlainInt16 Current => _array[_index];

            public void Reset() => _index = -1;
            public void Dispose() {}
        }

        public static bool operator ==(HandleArray5 l, HandleArray5 r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(HandleArray5 l, HandleArray5 r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }

    public readonly ref struct Monster {
        public const int SizeOf = 44;
        private const int _PaddingStart = 42;
        private const int _PaddingSize = 2;

        private readonly Span<byte> _buffer;
        public Span<byte> GetBuffer() => _buffer;

        public Monster(Span<byte> buffer) {
            if (buffer.Length != SizeOf) throw new InvalidOperationException("Buffer size doesn't match to the struct size!");
            _buffer = buffer;
        }

        public Vec Position => new Vec(_buffer.Slice(0, Vec.SizeOf));
        public Quat Rotation => new Quat(_buffer.Slice(12, Quat.SizeOf));
        public PlainInt16 Hp => new PlainInt16(_buffer.Slice(28, PlainInt16.SizeOf));
        public HandleArray5 Inventory => new HandleArray5(_buffer.Slice(30, HandleArray5.SizeOf));
        public PlainBool Aggressive => new PlainBool(_buffer.Slice(40, PlainBool.SizeOf));
        public _PlainColorId Color => new _PlainColorId(_buffer.Slice(41, _PlainColorId.SizeOf));

        public void CopyTo(Monster other) => _buffer.CopyTo(other._buffer);

        public void WriteDefault() {
            Position.WriteDefault();
            Rotation.WriteDefault();
            Hp.Write(100);
            Inventory.WriteDefault();
            Aggressive.Write(true);
            Color.Write(ColorId.Blue);
            _buffer.Slice(_PaddingStart, _PaddingSize).Fill(0);
        }

        public static bool operator ==(Monster l, Monster r) => l._buffer.SequenceEqual(r._buffer);
        public static bool operator !=(Monster l, Monster r) => !l._buffer.SequenceEqual(r._buffer);

        public override bool Equals(object obj) => false;
        public override int GetHashCode() => throw new NotSupportedException();
    }
}
