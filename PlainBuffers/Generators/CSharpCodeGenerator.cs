using System;
using System.IO;
using PlainBuffers.CodeGen;
using PlainBuffers.CodeGen.Data;

namespace PlainBuffers.Generators {
  public class CSharpCodeGenerator : IGenerator {
    private const string Indent = "    ";

    private readonly string[] _namespaces;

    public CSharpCodeGenerator(string[] namespaces) => _namespaces = namespaces ?? Array.Empty<string>();

    public INamingChecker NamingChecker { get; } = new CSharpNamingChecker();

    public void Generate(CodeGenData data, TextWriter writer) {
      WriteHeader(writer);
      writer.WriteLine();

      if (_namespaces.Length > 0)
        WriteNamespaces(writer);

      writer.WriteLine("#pragma warning disable 649");
      writer.WriteLine();

      using (var nsBlock = new BlockWriter(writer, Indent, 0, $"namespace {data.NameSpace}")) {
        for (var i = 0; i < data.Types.Length; i++) {
          var typeInfo = data.Types[i];
          switch (typeInfo) {
            case CodeGenEnum enumInfo:
              WriteEnum(enumInfo, nsBlock);
              break;
            case CodeGenArray arrayInfo:
              WriteArray(arrayInfo, nsBlock);
              break;
            case CodeGenStruct structInfo:
              WriteStruct(structInfo, nsBlock);
              break;
            default:
              throw new Exception("Unknown data type");
          }

          if (i < data.Types.Length - 1)
            nsBlock.WriteLine();
        }
      }
    }

    protected virtual void WriteHeader(TextWriter writer) {
      writer.WriteLine("// This file is auto-generated by the PlainBuffers compiler");
      writer.WriteLine($"// Generated at {DateTimeOffset.Now:O}");
      writer.WriteLine();

      writer.WriteLine("// ReSharper disable All");
      writer.WriteLine();

      writer.WriteLine("using System;");
      writer.WriteLine("using System.Runtime.InteropServices;");
    }

    private void WriteNamespaces(TextWriter writer) {
      foreach (var ns in _namespaces)
        writer.WriteLine($"using {ns};");

      writer.WriteLine();
    }

    protected virtual void WriteEnum(CodeGenEnum enumType, in BlockWriter nsBlock) {
      if (enumType.IsFlags)
        nsBlock.WriteLine("[Flags]");

      using (var typeBlock = nsBlock.Sub($"public enum {enumType.Name} : {enumType.UnderlyingType}")) {
        for (var i = 0; i < enumType.Items.Length; i++) {
          var item = enumType.Items[i];
          var comma = i < enumType.Items.Length - 1 ? "," : string.Empty;

          typeBlock.WriteLine($"{item.Name} = {item.Value}{comma}");
        }
      }
    }

    protected virtual void WriteArray(CodeGenArray arrayType, in BlockWriter nsBlock) {
      nsBlock.WriteLine("[StructLayout(LayoutKind.Explicit)]");
      using (var typeBlock = nsBlock.Sub($"public unsafe struct {arrayType.Name}")) {
        typeBlock.WriteLine($"public const int SizeOf = {arrayType.Size};");
        typeBlock.WriteLine($"public const int AlignmentOf = {arrayType.Alignment};");
        typeBlock.WriteLine($"public const int Length = {arrayType.Length};");

        typeBlock.WriteLine();
        typeBlock.WriteLine("[FieldOffset(0)] private fixed byte _buffer[SizeOf];");

        typeBlock.WriteLine();
        WriteArrayFields(arrayType, typeBlock);

        typeBlock.WriteLine();
        using (var wdBlock = typeBlock.Sub("public void WriteDefault()"))
        using (var ptrBlock = wdBlock.Sub("fixed (byte* ptr = _buffer)")) {
          using (var forBlock = ptrBlock.Sub("for (var i = 0; i < Length; i++)")) {
            var lValue = $"(*(({arrayType.ItemType}*)ptr + i))";
            PutWriteDefaultLine(forBlock, lValue, arrayType.ItemType, arrayType.ItemDefaultValueInfo);
          }
        }

        typeBlock.WriteLine();
        WriteEqualityOperators(arrayType.Name, typeBlock);

        typeBlock.WriteLine();
        WriteArrayIterator(typeBlock, arrayType, true);
        typeBlock.WriteLine();
        WriteArrayIterator(typeBlock, arrayType, false);
        typeBlock.WriteLine();
        WriteArrayEnumerator(typeBlock, arrayType, true);
        typeBlock.WriteLine();
        WriteArrayEnumerator(typeBlock, arrayType, false);
      }

      nsBlock.WriteLine();
      WriteArrayIndexingExtensions(nsBlock, arrayType);
    }

    protected virtual void WriteArrayFields(CodeGenArray arrayType, BlockWriter typeBlock) {
      var itemSize = arrayType.Size / arrayType.Length;
      for (var i = 0; i < arrayType.Length; i++)
        WriteField(typeBlock, i * itemSize, arrayType.ItemType, $"Item{i}");
    }

    protected static string GetRefAccessorPrefix(bool mutable) => mutable ? "Ref" : "RefReadonly";
    protected virtual string GetArrayIteratorTypeName(bool mutable) => $"{GetRefAccessorPrefix(mutable)}Iterator";
    protected virtual string GetArrayEnumeratorTypeName(bool mutable) => $"{GetRefAccessorPrefix(mutable)}Enumerator";

    protected virtual string GetArrayIndexExtensionsTypeName(string arrayTypeName) {
      return $"_{arrayTypeName}_IndexExtensions";
    }

    private void WriteArrayIterator(in BlockWriter arrayBlock, CodeGenArray arrayType, bool mutable) {
      var iteratorType = GetArrayIteratorTypeName(mutable);
      var enumeratorType = GetArrayEnumeratorTypeName(mutable);

      using (var iterBlock = arrayBlock.Sub($"public unsafe readonly ref struct {iteratorType}")) {
        iterBlock.WriteLine($"private readonly {arrayType.Name}* _ptr;");
        var modifier = mutable ? "ref" : "in";
        using (var ctorBlock = iterBlock.Sub($"public {iteratorType}({modifier} {arrayType.Name} array)")) {
          ctorBlock.WriteLine($"fixed ({arrayType.Name}* ptr = &array) _ptr = ptr;");
        }

        iterBlock.WriteLine($"public {enumeratorType} GetEnumerator() => new {enumeratorType}(_ptr);");
      }
    }

    private void WriteArrayEnumerator(in BlockWriter arrayBlock, CodeGenArray arrayType, bool mutable) {
      var enumeratorType = GetArrayEnumeratorTypeName(mutable);
      using (var enumeratorBlock = arrayBlock.Sub($"public unsafe ref struct {enumeratorType}")) {
        enumeratorBlock.WriteLine($"private readonly {arrayType.Name}* _ptr;");
        enumeratorBlock.WriteLine("private int _index;");
        using (var ctorBlock = enumeratorBlock.Sub($"public {enumeratorType}({arrayType.Name}* ptr)")) {
          ctorBlock.WriteLine("_ptr = ptr;");
          ctorBlock.WriteLine("_index = -1;");
        }

        var refType = mutable ? "ref" : "ref readonly";
        var derefExpr = $"*(({arrayType.ItemType}*)_ptr + _index)";
        enumeratorBlock.WriteLine($"public {refType} {arrayType.ItemType} Current => ref {derefExpr};");
        enumeratorBlock.WriteLine($"public bool MoveNext() => ++_index < {arrayType.Name}.Length;");

        enumeratorBlock.WriteLine("public void Reset() => _index = -1;");
        enumeratorBlock.WriteLine("public void Dispose() {}");
      }
    }

    private void WriteArrayIndexingExtensions(in BlockWriter nsBlock, CodeGenArray arrayType) {
      var typeName = GetArrayIndexExtensionsTypeName(arrayType.Name);
      using (var typeBlock = nsBlock.Sub($"public static unsafe class {typeName}")) {
        WriteArrayRefIndexerExtensionMethod(typeBlock, arrayType, true);
        WriteArrayRefIterExtensionMethod(typeBlock, arrayType.Name, true);
        typeBlock.WriteLine();
        WriteArrayRefIndexerExtensionMethod(typeBlock, arrayType, false);
        WriteArrayRefIterExtensionMethod(typeBlock, arrayType.Name, false);
      }
    }

    protected virtual void WriteArrayRefIndexerExtensionMethod(in BlockWriter typeBlock, CodeGenArray arrayType, bool mutable) {
      var refType = mutable ? "ref" : "ref readonly";
      var method = $"{GetRefAccessorPrefix(mutable)}At";
      var mod = mutable ? "ref" : "in";

      var expr = $"public static {refType} {arrayType.ItemType} {method}(this {mod} {arrayType.Name} array, int index)";
      using (var methodBlock = typeBlock.Sub(expr)) {
        WriteBoundsCheck(methodBlock, arrayType);
        using (var fixedBlock = methodBlock.Sub($"fixed ({arrayType.Name}* ptr = &array)")) {
          fixedBlock.WriteLine($"return ref *(({arrayType.ItemType}*)ptr + index);");
        }
      }
    }

    protected virtual void WriteBoundsCheck(BlockWriter methodBlock, CodeGenArray arrayType) {
      var iType = arrayType.ItemType;
      var aType = arrayType.Name;
      const string eType = "IndexOutOfRangeException";
      methodBlock.WriteLine($"if (index < 0 || sizeof({iType}) * index >= {aType}.SizeOf) throw new {eType}();");
    }

    private void WriteArrayRefIterExtensionMethod(in BlockWriter typeBlock, string arrayType, bool mutable) {
      var iterType = $"{arrayType}.{GetArrayIteratorTypeName(mutable)}";
      var method = $"{GetRefAccessorPrefix(mutable)}Iter";
      var mod = mutable ? "ref" : "in";

      var expr = $"public static {iterType} {method}(this {mod} {arrayType} array) => new {iterType}({mod} array);";
      typeBlock.WriteLine(expr);
    }

    protected virtual void WriteStruct(CodeGenStruct structType, in BlockWriter nsBlock) {
      nsBlock.WriteLine("[StructLayout(LayoutKind.Explicit)]");
      using (var typeBlock = nsBlock.Sub($"public unsafe struct {structType.Name}")) {
        typeBlock.WriteLine($"public const int SizeOf = {structType.Size};");
        typeBlock.WriteLine($"public const int AlignmentOf = {structType.Alignment};");

        if (structType.Padding != 0)
          typeBlock.WriteLine($"private const int _Padding = {structType.Padding};");

        typeBlock.WriteLine();
        typeBlock.WriteLine("[FieldOffset(0)] private fixed byte _buffer[SizeOf];");

        typeBlock.WriteLine();
        foreach (var field in structType.Fields)
          WriteField(typeBlock, field.Offset, field.Type, field.Name);

        typeBlock.WriteLine();
        using (var wdBlock = typeBlock.Sub("public void WriteDefault()")) {
          foreach (var field in structType.Fields) {
            PutWriteDefaultLine(wdBlock, field.Name, field.Type, field.DefaultValueInfo);
          }

          if (structType.Padding != 0)
            WritePaddingFiller(wdBlock);
        }

        typeBlock.WriteLine();
        WriteEqualityOperators(structType.Name, typeBlock);
      }
    }

    protected virtual void WriteField(in BlockWriter typeBlock, int offset, string fieldType, string fieldName) {
      var attributes = $"FieldOffset({offset})";

      // `bool` is not blittable type, so we need to set format explicitly
      if (fieldType == "bool")
        attributes += ", MarshalAs(UnmanagedType.U1)";

      typeBlock.WriteLine($"[{attributes}] public {fieldType} {fieldName};");
    }

    protected virtual void WriteEqualityOperators(string type, in BlockWriter typeBlock) {
      using (var eqBlock = typeBlock.Sub($"public static bool operator ==(in {type} l, in {type} r)")) {
        using (var rFxd = eqBlock.Sub("fixed (byte* __l = l._buffer, __r = r._buffer)")) {
          rFxd.WriteLine("return new Span<byte>(__l, SizeOf).SequenceEqual(new Span<byte>(__r, SizeOf));");
        }
      }

      typeBlock.WriteLine($"public static bool operator !=(in {type} l, in {type} r) => !(l == r);");
      typeBlock.WriteLine();
      typeBlock.WriteLine($"public override bool Equals(object obj) => obj is {type} casted && this == casted;");
      typeBlock.WriteLine("public override int GetHashCode() => throw new NotSupportedException();");
    }

    protected virtual void WritePaddingFiller(in BlockWriter writeDefaultBlock) {
      using (var fxdBlock = writeDefaultBlock.Sub("fixed (byte* __ptr = _buffer)")) {
        fxdBlock.WriteLine("new Span<byte>(__ptr + (SizeOf - _Padding), _Padding).Fill(0);");
      }
    }

    protected static void PutWriteDefaultLine(in BlockWriter block, string lhs, string type,
      in DefaultValueInfo valInfo) {
      switch (valInfo.Variant) {
        case DefaultValueVariant.WriteZeroes:
          block.WriteLine($"{lhs} = default;");
          break;
        case DefaultValueVariant.AssignValue:
          block.WriteLine($"{lhs} = {valInfo.Identifier};");
          break;
        case DefaultValueVariant.AssignTypeMember:
          block.WriteLine($"{lhs} = {type}.{valInfo.Identifier};");
          break;
        case DefaultValueVariant.CallWriteDefaultMethod:
          block.WriteLine($"{lhs}.WriteDefault();");
          break;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }
  }
}