using System;
using System.Collections.Generic;
using System.IO;
using PlainBuffers.CodeGen;
using PlainBuffers.CodeGen.Data;

namespace PlainBuffers.Generators {
  public class CSharpUnsafeStructsGenerator : CSharpAbstractGenerator {
    protected override void WriteHeader(TextWriter writer) {
      writer.WriteLine("// This file is auto-generated by the PlainBuffers compiler");
      writer.WriteLine($"// Generated at {DateTimeOffset.Now:O}");
      writer.WriteLine();

      writer.WriteLine("// ReSharper disable All");
      writer.WriteLine();

      writer.WriteLine("using System;");
      writer.WriteLine("using System.Runtime.CompilerServices;");
      writer.WriteLine("using System.Runtime.InteropServices;");
      writer.WriteLine();

    }

    protected override void WriteEnum(CodeGenEnum enumType, in BlockWriter nsBlock, HashSet<string> valueTypes) {
      if (enumType.IsFlags)
        nsBlock.WriteLine("[Flags]");

      using (var typeBlock = nsBlock.Sub($"public enum {enumType.Name} : {enumType.UnderlyingType}")) {
        for (var i = 0; i < enumType.Items.Length; i++) {
          var item = enumType.Items[i];
          var comma = i < enumType.Items.Length - 1 ? "," : string.Empty;

          typeBlock.WriteLine($"{item.Name} = {item.Value}{comma}");
        }
      }

      valueTypes.Add(enumType.Name);
    }

    protected override void WriteArray(CodeGenArray arrayType, in BlockWriter nsBlock, HashSet<string> valueTypes) {
      using (var typeBlock = nsBlock.Sub($"public unsafe struct {arrayType.Name}")) {
        typeBlock.WriteLine($"public const int SizeOf = {arrayType.Size};");
        typeBlock.WriteLine($"public const int Length = {arrayType.Length};");
        typeBlock.WriteLine();
        typeBlock.WriteLine("private fixed byte _buffer[SizeOf];");

        var itemType = arrayType.ItemType;
        var isValueType = valueTypes.Contains(itemType);

        typeBlock.WriteLine();
        using (var wdBlock = typeBlock.Sub("public void WriteDefault()"))
        using (var forBlock = wdBlock.Sub("for (var i = 0; i < Length; i++)")) {
          if (isValueType) {
            var isEnum = !CSharpPrimitives.Contains(itemType);
            var defaultValue = isEnum ? $"{itemType}.{arrayType.ItemDefaultValue}" : arrayType.ItemDefaultValue;
            forBlock.WriteLine($"this[i] = {defaultValue};");
          }
          else {
            forBlock.WriteLine("this[i].WriteDefault();");
          }
        }

        typeBlock.WriteLine();
        using (var idxBlock = typeBlock.Sub($"public ref {itemType} this[int index]"))
        using (var getBlock = idxBlock.Sub("get")) {
          var sizeExpr = isValueType ? $"sizeof({itemType})" : $"{itemType}.SizeOf";
          getBlock.WriteLine($"if (index < 0 || {sizeExpr} * index >= SizeOf) throw new IndexOutOfRangeException();");
          getBlock.WriteLine("return ref At(index);");
        }

        typeBlock.WriteLine();
        using (var atBlock = typeBlock.Sub($"private ref {itemType} At(int index)")) {
          using (var retBlock = atBlock.Sub("fixed (byte* __ptr = _buffer)")) {
            retBlock.WriteLine($"return ref *(({itemType}*)__ptr + index);");
          }
        }

        typeBlock.WriteLine();
        WriteArrayEnumerator(arrayType.Name, itemType, typeBlock);

        typeBlock.WriteLine();
        WriteEqualityOperators(arrayType.Name, typeBlock);
      }
    }

    private static void WriteArrayEnumerator(string arrayType, string item, BlockWriter arrayBlock) {
      var enumeratorType = $"_EnumeratorOf{arrayType}";
      arrayBlock.WriteLine($"public {enumeratorType} GetEnumerator() => new {enumeratorType}(ref this);");

      arrayBlock.WriteLine();
      using (var enumeratorBlock = arrayBlock.Sub($"public unsafe ref struct {enumeratorType}")) {
        enumeratorBlock.WriteLine($"private readonly {arrayType}* _arrayPtr;");
        enumeratorBlock.WriteLine("private int _index;");

        enumeratorBlock.WriteLine();
        using (var ctorBlock = enumeratorBlock.Sub($"public {enumeratorType}(ref {arrayType} array)")) {
          ctorBlock.WriteLine($"_arrayPtr = ({arrayType}*) Unsafe.AsPointer(ref array);");
          ctorBlock.WriteLine("_index = -1;");
        }

        enumeratorBlock.WriteLine();
        enumeratorBlock.WriteLine("public bool MoveNext() => ++_index < Length;");
        enumeratorBlock.WriteLine($"public ref {item} Current => ref (*_arrayPtr).At(_index);");

        enumeratorBlock.WriteLine();
        enumeratorBlock.WriteLine("public void Reset() => _index = -1;");
        enumeratorBlock.WriteLine("public void Dispose() {}");
      }
    }

    protected override void WriteStruct(CodeGenStruct structType, in BlockWriter nsBlock, HashSet<string> valueTypes) {
      nsBlock.WriteLine("[StructLayout(LayoutKind.Explicit)]");
      using (var typeBlock = nsBlock.Sub($"public unsafe struct {structType.Name}")) {
        typeBlock.WriteLine($"public const int SizeOf = {structType.Size};");

        if (structType.Padding != 0)
          typeBlock.WriteLine($"private const int _Padding = {structType.Padding};");

        typeBlock.WriteLine();
        typeBlock.WriteLine("[FieldOffset(0)] private fixed byte _buffer[SizeOf];");

        typeBlock.WriteLine();
        foreach (var field in structType.Fields) {
          typeBlock.WriteLine($"[FieldOffset({field.Offset})] public {field.Type} {field.Name};");
        }

        typeBlock.WriteLine();
        using (var wdBlock = typeBlock.Sub("public void WriteDefault()")) {
          foreach (var field in structType.Fields) {
            var isValueType = valueTypes.Contains(field.Type);
            var isEnum = isValueType && !CSharpPrimitives.Contains(field.Type);
            var defaultValue = isEnum ? $"{field.Type}.{field.DefaultValue}" : field.DefaultValue;

            wdBlock.WriteLine(isValueType
              ? $"{field.Name} = {defaultValue};"
              : $"{field.Name}.WriteDefault();");
          }

          if (structType.Padding != 0) {
            using (var retBlock = wdBlock.Sub("fixed (byte* __ptr = _buffer)")) {
              retBlock.WriteLine("new Span<byte>(__ptr + (SizeOf - _Padding), _Padding).Fill(0);");
            }
          }
        }

        typeBlock.WriteLine();
        WriteEqualityOperators(structType.Name, typeBlock);
      }
    }

    private static void WriteEqualityOperators(string type, in BlockWriter typeBlock) {
      using (var eqBlock = typeBlock.Sub($"public static bool operator ==(in {type} l, in {type} r)")) {
        eqBlock.WriteLine("fixed (byte* __l = l._buffer)");
        using (var rFxd = eqBlock.Sub("fixed (byte* __r = r._buffer)")) {
          rFxd.WriteLine("return new Span<byte>(__l, SizeOf).SequenceEqual(new Span<byte>(__r, SizeOf));");
        }
      }

      typeBlock.WriteLine($"public static bool operator !=(in {type} l, in {type} r) => !(l == r);");
      typeBlock.WriteLine();
      typeBlock.WriteLine($"public override bool Equals(object obj) => obj is {type} casted && this == casted;");
      typeBlock.WriteLine("public override int GetHashCode() => throw new NotSupportedException();");
    }
  }
}